<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Xiangqi — Mobile-first, Responsive, Smart AI</title>
<style>
  :root {
    --bg: #f7f3e9;
    --grid: #7b5e2f;
    --river: #dcd2b6;
    --red: #c0392b;
    --black: #2c3e50;
    --hint: #27ae60;
    --sel: #f1c40f;
    --piece-fill: #fff;
    --piece-stroke: #333;
  }
  html, body {
    height: 100%;
    margin: 0;
    background: var(--bg);
    color: #222;
    font: 16px/1.4 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans", "PingFang SC", "Hiragino Sans", "Microsoft YaHei", "Helvetica Neue", Arial, sans-serif;
  }
  .app {
    max-width: 820px;
    margin: 0 auto;
    padding: 8px 10px 18px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  .toolbar {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items: center;
    justify-content: space-between;
  }
  .left, .right {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items: center;
  }
  button, select, input[type="number"], input[type="range"] {
    border: 1px solid #ccc;
    background: white;
    color: #222;
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 14px;
  }
  button {
    cursor: pointer;
  }
  button:disabled {
    opacity: 0.6; cursor: not-allowed;
  }
  .status {
    font-weight: 600;
    color: #555;
  }

  /* Board container maintains Xiangqi aspect ratio (9 cols x 10 rows) */
  .board-wrap {
    width: 100%;
    /* 10 rows high vs 9 cols wide: height/width = 10/9 */
    aspect-ratio: 9 / 10;
    background: var(--river);
    border-radius: 12px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.08);
    position: relative;
    user-select: none;
    touch-action: manipulation;
  }
  svg {
    width: 100%; height: 100%;
    display: block;
  }
  .grid-line {
    stroke: var(--grid);
    stroke-width: 1.5;
  }
  .river-text {
    font: 700 6.2px/1.2 "STKaiti","Kaiti SC","KaiTi","Kai","Noto Serif CJK SC",serif;
    fill: rgba(0,0,0,0.25);
    letter-spacing: 1px;
  }
  .piece {
    cursor: pointer;
  }
  .p-circle {
    fill: var(--piece-fill);
    stroke: var(--piece-stroke);
    stroke-width: 1.2;
  }
  .p-label {
    font: 700 7.2px/1 "STKaiti","Kaiti SC","KaiTi","Kai","Noto Serif CJK SC",serif;
    text-anchor: middle;
    dominant-baseline: central;
  }
  .p-red .p-label { fill: var(--red); }
  .p-black .p-label { fill: var(--black); }
  .hint {
    fill: rgba(39,174,96,0.18);
    stroke: var(--hint);
    stroke-width: 0.8;
  }
  .sel {
    fill: rgba(241,196,15,0.2);
    stroke: var(--sel);
    stroke-width: 0.9;
  }
  .coords {
    font: 500 5px/1.1 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    fill: rgba(0,0,0,0.35);
  }
  .footer {
    font-size: 12px;
    color: #666;
    text-align: center;
    margin-top: 6px;
  }
</style>
</head>
<body>
  <div class="app">
    <div class="toolbar">
      <div class="left">
        <button id="newBtn">New game</button>
        <button id="switchBtn">Switch sides</button>
        <button id="undoBtn">Undo</button>
      </div>
      <div class="right">
        <label>AI time
          <input id="timeRange" type="range" min="500" max="5000" step="250" value="2000" />
        </label>
        <span id="timeLabel" class="status">2.0s/move</span>
      </div>
    </div>

    <div class="status" id="status">Your move as Red.</div>

    <div class="board-wrap" id="boardWrap" aria-label="Xiangqi board">
      <!-- SVG board injected by JS -->
    </div>

    <div class="footer">Tip: Tap once to select a piece, then tap a highlighted dot to move. Long-press Undo if you blunder.</div>
  </div>

<script>
(function(){
  "use strict";

  // Core constants
  const RED = 1, BLACK = -1;
  const PIECES = {
    G: 'G', // General: 帥/將
    A: 'A', // Advisor: 仕/士
    E: 'E', // Elephant: 相/象
    H: 'H', // Horse: 馬
    R: 'R', // Chariot: 車
    C: 'C', // Cannon: 炮/砲
    S: 'S'  // Soldier: 兵/卒
  };

  // UI elements
  const elWrap = document.getElementById('boardWrap');
  const elStatus = document.getElementById('status');
  const newBtn = document.getElementById('newBtn');
  const switchBtn = document.getElementById('switchBtn');
  const undoBtn = document.getElementById('undoBtn');
  const timeRange = document.getElementById('timeRange');
  const timeLabel = document.getElementById('timeLabel');

  // SVG setup constants
  // Logical board coordinates: 9 files (x:0..8), 10 ranks (y:0..9)
  // We'll draw using a 90x100 viewBox (each grid cell ~10 units)
  const VB_W = 90, VB_H = 100;
  const CELL = 10;
  const PAD = 5; // padding inside viewBox
  const BOARD_X0 = PAD, BOARD_Y0 = PAD;
  const BOARD_X1 = VB_W - PAD, BOARD_Y1 = VB_H - PAD;

  // Starting position (10x9 board), from Red's perspective at bottom
  // Each cell: null or {t:pieceType, c:color}
  function startPosition() {
    // Empty 10x9
    const b = Array.from({length: 10}, () => Array(9).fill(null));
    // Place pieces
    const place = (x, y, t, c) => b[y][x] = { t, c };
    // Chariots
    place(0,9,PIECES.R,RED); place(8,9,PIECES.R,RED);
    place(0,0,PIECES.R,BLACK); place(8,0,PIECES.R,BLACK);
    // Horses
    place(1,9,PIECES.H,RED); place(7,9,PIECES.H,RED);
    place(1,0,PIECES.H,BLACK); place(7,0,PIECES.H,BLACK);
    // Elephants
    place(2,9,PIECES.E,RED); place(6,9,PIECES.E,RED);
    place(2,0,PIECES.E,BLACK); place(6,0,PIECES.E,BLACK);
    // Advisors
    place(3,9,PIECES.A,RED); place(5,9,PIECES.A,RED);
    place(3,0,PIECES.A,BLACK); place(5,0,PIECES.A,BLACK);
    // Generals
    place(4,9,PIECES.G,RED);
    place(4,0,PIECES.G,BLACK);
    // Cannons
    place(1,7,PIECES.C,RED); place(7,7,PIECES.C,RED);
    place(1,2,PIECES.C,BLACK); place(7,2,PIECES.C,BLACK);
    // Soldiers
    [0,2,4,6,8].forEach(x => place(x,6,PIECES.S,RED));
    [0,2,4,6,8].forEach(x => place(x,3,PIECES.S,BLACK));
    return b;
  }

  // Chinese labels
  const LABELS = {
    [PIECES.G]: { [RED]:'帥', [BLACK]:'將' },
    [PIECES.A]: { [RED]:'仕', [BLACK]:'士' },
    [PIECES.E]: { [RED]:'相', [BLACK]:'象' },
    [PIECES.H]: { [RED]:'馬', [BLACK]:'馬' },
    [PIECES.R]: { [RED]:'車', [BLACK]:'車' },
    [PIECES.C]: { [RED]:'炮', [BLACK]:'砲' },
    [PIECES.S]: { [RED]:'兵', [BLACK]:'卒' },
  };

  // Game state
  let board = startPosition();
  let sideToMove = RED; // Red moves first
  let humanSide = RED;  // Human plays Red by default
  let selected = null;  // {x,y} selected square
  let legalMovesFromSel = []; // cached legal moves from selected
  let history = []; // move history for undo, storing {move, captured, prevHash, ...}
  let gameOver = false;
  let searching = false;
  let aiTimeMs = parseInt(timeRange.value,10);

  // Transposition table (simple)
  const TT = new Map();

  // Zobrist hashing
  const Z = (() => {
    const rand32 = () => (Math.random()*0x100000000)>>>0;
    const keys = {};
    for (const t of Object.values(PIECES)) {
      keys[t] = { [RED]:[], [BLACK]:[] };
      for (let y=0;y<10;y++){
        keys[t][RED][y] = [];
        keys[t][BLACK][y] = [];
        for (let x=0;x<9;x++){
          keys[t][RED][y][x] = rand32();
          keys[t][BLACK][y][x] = rand32();
        }
      }
    }
    const sideKey = rand32();
    return { keys, sideKey };
  })();

  let hash = computeHash(board, sideToMove);

  function computeHash(b, stm){
    let h = 0|0;
    for (let y=0;y<10;y++){
      for (let x=0;x<9;x++){
        const p = b[y][x];
        if (!p) continue;
        h ^= Z.keys[p.t][p.c][y][x];
      }
    }
    if (stm === RED) h ^= Z.sideKey;
    return h>>>0;
  }

  function toggleSide(s){ return -s; }

  // Board helpers
  function inBoard(x,y){ return x>=0 && x<9 && y>=0 && y<10; }
  function palaceContains(x,y,c){
    if (c===RED) return (x>=3 && x<=5 && y>=7 && y<=9);
    else return (x>=3 && x<=5 && y>=0 && y<=2);
  }
  function riverCrossed(y,c){
    return c===RED ? (y<=4) : (y>=5);
  }

  // Move representation
  // move = {fx,fy,tx,ty, piece:{t,c}, capture?:{t,c} }
  function clonePiece(p){ return p?{t:p.t, c:p.c}:null; }

  // Make/undo moves with hash updates
  function makeMove(m){
    const {fx,fy,tx,ty} = m;
    const p = board[fy][fx];
    const cap = board[ty][tx];

    // hash out from origin
    hash ^= Z.keys[p.t][p.c][fy][fx];
    // hash out captured
    if (cap) hash ^= Z.keys[cap.t][cap.c][ty][tx];

    // apply move
    board[ty][tx] = p;
    board[fy][fx] = null;

    // hash in moved piece at new square
    hash ^= Z.keys[p.t][p.c][ty][tx];

    // side toggle
    sideToMove = toggleSide(sideToMove);
    hash ^= Z.sideKey;

    return cap;
  }
  function undoMove(m, captured){
    const {fx,fy,tx,ty} = m;
    const p = board[ty][tx];

    // hash out moved piece at new square
    hash ^= Z.keys[p.t][p.c][ty][tx];

    // restore
    board[fy][fx] = p;
    board[ty][tx] = captured || null;

    // hash in moved piece at origin
    hash ^= Z.keys[p.t][p.c][fy][fx];
    if (captured) hash ^= Z.keys[captured.t][captured.c][ty][tx];

    // side toggle back
    sideToMove = toggleSide(sideToMove);
    hash ^= Z.sideKey;
  }

  // Get all moves for side c (legal only)
  function generateLegalMoves(c){
    const moves = [];
    for (let y=0;y<10;y++){
      for (let x=0;x<9;x++){
        const p = board[y][x];
        if (!p || p.c !== c) continue;
        const pseudo = generatePseudoMovesFor(x,y,p);
        for (const m of pseudo){
          // filter illegal (self-check and flying general rule handled in check)
          const cap = makeMove(m);
          const inCheck = isInCheck(c);
          undoMove(m, cap);
          if (!inCheck) moves.push(m);
        }
      }
    }
    // Move ordering: captures first, closer-to-general moves heuristics
    moves.sort((a,b)=>{
      const ca = board[a.ty][a.tx] ? 1 : (a.capture?1:0); // not available here; leave simple
      const cb = board[b.ty][b.tx] ? 1 : (b.capture?1:0);
      return cb - ca;
    });
    return moves;
  }

  function generatePseudoMovesFor(x,y,p){
    const out = [];
    const add = (tx,ty)=>{ if (inBoard(tx,ty)){
      const t = board[ty][tx];
      if (!t || t.c !== p.c){
        out.push({fx:x,fy:y,tx,ty,piece:clonePiece(p), capture: t?clonePiece(t):null});
      }
    }};
    switch(p.t){
      case PIECES.G: {
        const deltas = [[0,1],[0,-1],[1,0],[-1,0]];
        for (const [dx,dy] of deltas){
          const tx=x+dx, ty=y+dy;
          if (inBoard(tx,ty) && palaceContains(tx,ty,p.c)) add(tx,ty);
        }
        // Flying general
        // Look along the file to find opposing general with no blocking pieces
        let ty = y + (p.c===RED ? -1 : 1);
        let blocked = false, gSeen = false;
        for (; ty>=0 && ty<10; ty += (p.c===RED ? -1 : 1)){
          const t = board[ty][x];
          if (t){
            if (t.t === PIECES.G && t.c !== p.c && !blocked){
              // can move to any square between? In practice, it's a direct capture move if no blockers
              out.push({fx:x,fy:y,tx:x,ty:ty,piece:clonePiece(p), capture: clonePiece(t)});
            }
            blocked = true; break;
          }
        }
        break;
      }
      case PIECES.A: {
        const deltas = [[1,1],[1,-1],[-1,1],[-1,-1]];
        for (const [dx,dy] of deltas){
          const tx=x+dx, ty=y+dy;
          if (inBoard(tx,ty) && palaceContains(tx,ty,p.c)) add(tx,ty);
        }
        break;
      }
      case PIECES.E: {
        const deltas = [[2,2],[2,-2],[-2,2],[-2,-2]];
        for (const [dx,dy] of deltas){
          const tx=x+dx, ty=y+dy;
          const bx=x+dx/2, by=y+dy/2; // elephant eye
          if (!inBoard(tx,ty)) continue;
          if (p.c===RED && ty<5) continue; // cannot cross river
          if (p.c===BLACK && ty>4) continue;
          if (board[by][bx]) continue; // blocked
          const t = board[ty][tx];
          if (!t || t.c !== p.c) out.push({fx:x,fy:y,tx,ty,piece:clonePiece(p), capture: t?clonePiece(t):null});
        }
        break;
      }
      case PIECES.H: {
        // Horse with leg rule
        const steps = [
          {leg:[0,-1], dst:[-1,-2]},{leg:[0,-1], dst:[1,-2]},
          {leg:[1,0], dst:[2,-1]},{leg:[1,0], dst:[2,1]},
          {leg:[0,1], dst:[1,2]},{leg:[0,1], dst:[-1,2]},
          {leg:[-1,0], dst:[-2,1]},{leg:[-1,0], dst:[-2,-1]},
        ];
        for (const s of steps){
          const lx=x+s.leg[0], ly=y+s.leg[1];
          if (!inBoard(lx,ly) || board[ly][lx]) continue; // leg blocked
          const tx=x+s.dst[0], ty=y+s.dst[1];
          if (!inBoard(tx,ty)) continue;
          const t=board[ty][tx];
          if (!t || t.c !== p.c) out.push({fx:x,fy:y,tx,ty,piece:clonePiece(p), capture: t?clonePiece(t):null});
        }
        break;
      }
      case PIECES.R: {
        // Rook-like sliding
        slide(x,y,1,0,p,out); slide(x,y,-1,0,p,out);
        slide(x,y,0,1,p,out); slide(x,y,0,-1,p,out);
        break;
      }
      case PIECES.C: {
        // Cannon: move like rook; capture requires exactly one screen
        cannonMoves(x,y,p,out);
        break;
      }
      case PIECES.S: {
        const dir = (p.c===RED)? -1 : 1; // Red moves up (y-1), Black down (y+1)
        const forwardY = y + dir;
        if (inBoard(x,forwardY)) add(x,forwardY);
        if (riverCrossed(y,p.c)){
          // side moves
          if (inBoard(x-1,y)) add(x-1,y);
          if (inBoard(x+1,y)) add(x+1,y);
        }
        break;
      }
    }
    return out;
  }

  function slide(x,y,dx,dy,p,out){
    let tx=x+dx, ty=y+dy;
    while(inBoard(tx,ty)){
      const t = board[ty][tx];
      if (!t){
        out.push({fx:x,fy:y,tx,ty,piece:clonePiece(p), capture:null});
      } else {
        if (t.c !== p.c) out.push({fx:x,fy:y,tx,ty,piece:clonePiece(p), capture:clonePiece(t)});
        break;
      }
      tx+=dx; ty+=dy;
    }
  }

  function cannonMoves(x,y,p,out){
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for (const [dx,dy] of dirs){
      // non-capturing moves until first blocker
      let tx=x+dx, ty=y+dy;
      while(inBoard(tx,ty) && !board[ty][tx]){
        out.push({fx:x,fy:y,tx,ty,piece:clonePiece(p), capture:null});
        tx+=dx; ty+=dy;
      }
      // one screen, then capture exactly next occupied of opposite color
      tx+=dx; ty+=dy;
      while(inBoard(tx,ty)){
        const t = board[ty][tx];
        if (t){
          if (t.c !== p.c){
            out.push({fx:x,fy:y,tx,ty,piece:clonePiece(p), capture:clonePiece(t)});
          }
          break;
        }
        tx+=dx; ty+=dy;
      }
    }
  }

  // Check detection, including flying general
  function isInCheck(color){
    // Find general position
    let gx=-1, gy=-1;
    for (let y=0;y<10;y++){
      for (let x=0;x<9;x++){
        const p=board[y][x];
        if (p && p.t===PIECES.G && p.c===color){ gx=x; gy=y; }
      }
    }
    const opp = -color;

    // 1) Rook/Chariot & Cannon & General along ranks/files
    // Up
    let seenScreen=false;
    for (let y=gy-1;y>=0;y--){
      const t=board[y][gx];
      if (!t) continue;
      if (!seenScreen){
        if (t.c===opp && (t.t===PIECES.R || t.t===PIECES.G)) return true;
        if (t) { seenScreen=true; }
      } else {
        if (t.c===opp && t.t===PIECES.C) return true;
        break;
      }
    }
    // Down
    seenScreen=false;
    for (let y=gy+1;y<10;y++){
      const t=board[y][gx];
      if (!t) continue;
      if (!seenScreen){
        if (t.c===opp && (t.t===PIECES.R || t.t===PIECES.G)) return true;
        if (t) { seenScreen=true; }
      } else {
        if (t.c===opp && t.t===PIECES.C) return true;
        break;
      }
    }
    // Left
    seenScreen=false;
    for (let x=gx-1;x>=0;x--){
      const t=board[gy][x];
      if (!t) continue;
      if (!seenScreen){
        if (t.c===opp && t.t===PIECES.R) return true;
        if (t) { seenScreen=true; }
      } else {
        if (t.c===opp && t.t===PIECES.C) return true;
        break;
      }
    }
    // Right
    seenScreen=false;
    for (let x=gx+1;x<9;x++){
      const t=board[gy][x];
      if (!t) continue;
      if (!seenScreen){
        if (t.c===opp && t.t===PIECES.R) return true;
        if (t) { seenScreen=true; }
      } else {
        if (t.c===opp && t.t===PIECES.C) return true;
        break;
      }
    }

    // 2) Horse threats (check leg)
    const horseChecks = [
      {leg:[0,-1], dst:[-1,-2]},{leg:[0,-1], dst:[1,-2]},
      {leg:[1,0], dst:[2,-1]},{leg:[1,0], dst:[2,1]},
      {leg:[0,1], dst:[1,2]},{leg:[0,1], dst:[-1,2]},
      {leg:[-1,0], dst:[-2,1]},{leg:[-1,0], dst:[-2,-1]},
    ];
    for (const h of horseChecks){
      const lx = gx + h.leg[0], ly = gy + h.leg[1];
      const tx = gx + h.dst[0], ty = gy + h.dst[1];
      if (!inBoard(lx,ly) || !inBoard(tx,ty)) continue;
      if (board[ly][lx]) continue; // leg blocked
      const t = board[ty][tx];
      if (t && t.c===opp && t.t===PIECES.H) return true;
    }

    // 3) Soldier threats
    // Opponent soldiers move toward our general
    const dir = (opp===RED)? -1 : 1;
    const sy = gy + dir;
    const candidates = [[gx,sy],[gx-1,gy],[gx+1,gy]];
    for (const [sx,syy] of candidates){
      if (inBoard(sx,syy)){
        const t = board[syy][sx];
        if (t && t.c===opp && t.t===PIECES.S){
          // Ensure soldier would legally attack that way
          if (syy===gy+dir || (riverCrossed(syy,opp) && (sx===gx-1 || sx===gx+1)))
            return true;
        }
      }
    }

    // 4) Advisor/Elephant diagonal checks from adjacent diagonals (rare but cover)
    const diag1 = [[1,1],[1,-1],[-1,1],[-1,-1]];
    for (const [dx,dy] of diag1){
      const tx=gx+dx, ty=gy+dy;
      if (!inBoard(tx,ty)) continue;
      const t=board[ty][tx];
      if (!t || t.c!==opp) continue;
      if (t.t===PIECES.A && palaceContains(tx,ty,opp)) return true;
      if (t.t===PIECES.E){
        // Elephant attacks two steps away only; General adjacent isn't attacked by Elephant by rules
      }
    }
    return false;
  }

  // Evaluation
  const VAL = {
    [PIECES.G]: 10000,
    [PIECES.R]: 600,
    [PIECES.C]: 350,
    [PIECES.H]: 300,
    [PIECES.E]: 120,
    [PIECES.A]: 120,
    [PIECES.S]: 70,
  };
  // Simple piece-square bonuses (favor center, advance soldiers)
  function pieceSquareBonus(t, c, x, y){
    const yRed = 9 - y; // mirror for red at bottom
    const yy = (c===RED) ? yRed : y;
    const center = (x===4? 8 : (x===3||x===5?4:0));
    switch(t){
      case PIECES.S:
        return (riverCrossed( (c===RED? y : yRed), c) ? 50 : 0) + yy*2 + center;
      case PIECES.H:
        return center + 4;
      case PIECES.C:
        return center + 6;
      case PIECES.R:
        return center + 10;
      case PIECES.E:
        return palaceContains(x, y, c) ? 6 : 0;
      case PIECES.A:
        return palaceContains(x, y, c) ? 8 : -5;
      case PIECES.G:
        return 0;
      default: return 0;
    }
  }

  function evaluate(){
    // Positive is good for sideToMove (negamax-friendly after perspective switch in search)
    let scoreRed = 0, scoreBlack = 0;
    for (let y=0;y<10;y++){
      for (let x=0;x<9;x++){
        const p = board[y][x];
        if (!p) continue;
        const base = VAL[p.t];
        const pst = pieceSquareBonus(p.t, p.c, x, y);
        if (p.c===RED) scoreRed += base + pst;
        else scoreBlack += base + pst;
      }
    }
    // King safety: penalize if in check
    if (isInCheck(RED)) scoreRed -= 20;
    if (isInCheck(BLACK)) scoreBlack -= 20;

    const evalScore = scoreRed - scoreBlack;
    // Return from perspective of side to move
    return (sideToMove===RED) ? evalScore : -evalScore;
  }

  // Search: iterative deepening alpha-beta (negamax)
  function searchRoot(timeMs){
    const start = performance.now();
    let best = null;
    let bestScore = -Infinity;
    let depth = 1;
    let nodes = 0;
    const deadline = start + timeMs;

    const rootMoves = generateLegalMoves(sideToMove);
    if (rootMoves.length===0){
      return { move: null, score: isInCheck(sideToMove) ? -999999 : 0, depth: 0, nodes: 0 };
    }

    // Move ordering: quick heuristic captures first already applied in generation
    // Killer moves storage
    const killers = Array.from({length:32},()=>({a:null,b:null}));

    while (performance.now() < deadline - 8) {
      let thisBest = null;
      let thisBestScore = -Infinity;

      for (let i=0;i<rootMoves.length;i++){
        const m = rootMoves[i];
        const cap = makeMove(m);
        const score = -alphaBeta(depth-1, -999999, 999999, deadline, killers, 1);
        undoMove(m,cap);
        nodes++;

        // PV move to front
        if (score > thisBestScore){
          thisBestScore = score;
          thisBest = m;
          // reorder
          rootMoves.splice(i,1);
          rootMoves.unshift(m);
        }
        if (performance.now() > deadline - 2) break;
      }

      if (thisBest){
        best = thisBest;
        bestScore = thisBestScore;
      } else {
        break;
      }
      depth++;
      if (depth>12) break; // practical cap for mobile
    }
    return { move: best, score: bestScore, depth: depth-1, nodes };
  }

  function alphaBeta(depth, alpha, beta, deadline, killers, ply){
    if (performance.now() > deadline) {
      // Quiescence-like stand-pat to avoid blunders if time’s up
      return evaluate();
    }
    if (depth===0) {
      return quiescence(alpha, beta, deadline);
    }
    const tt = TT.get(hash);
    if (tt && tt.depth >= depth){
      if (tt.flag === 0) return tt.score;
      if (tt.flag === -1 && tt.score <= alpha) return alpha;
      if (tt.flag === 1 && tt.score >= beta) return beta;
    }

    let bestScore = -999999;
    let bestMove = null;

    let moves = generateLegalMoves(sideToMove);

    // Move ordering: try TT move, then captures, then killers
    if (tt && tt.move){
      const idx = moves.findIndex(m => sameMove(m, tt.move));
      if (idx>=0){ const mv = moves.splice(idx,1)[0]; moves.unshift(mv); }
    }
    const k = killers[ply]||{};
    for (const km of [k.a,k.b]){
      if (!km) continue;
      const idx = moves.findIndex(m => sameMove(m, km));
      if (idx>0){ const mv = moves.splice(idx,1)[0]; moves.splice(1,0,mv); }
    }

    for (const m of moves){
      const cap = makeMove(m);
      const score = -alphaBeta(depth-1, -beta, -alpha, deadline, killers, ply+1);
      undoMove(m, cap);
      if (score > bestScore){ bestScore = score; bestMove = m; }
      if (bestScore > alpha){
        alpha = bestScore;
      }
      if (alpha >= beta){
        // store killer
        if (!m.capture){
          const kk = killers[ply]||{a:null,b:null};
          if (!kk.a || !sameMove(kk.a,m)) { kk.b = kk.a; kk.a = m; killers[ply] = kk; }
        }
        break;
      }
      if (performance.now() > deadline) break;
    }

    // store TT
    let flag = 0;
    if (bestScore <= alpha) flag = -1;
    else if (bestScore >= beta) flag = 1;
    TT.set(hash, {depth, score: bestScore, flag, move: bestMove});
    return bestScore;
  }

  function sameMove(a,b){
    return a && b && a.fx===b.fx && a.fy===b.fy && a.tx===b.tx && a.ty===b.ty && a.piece.t===b.piece.t && a.piece.c===b.piece.c;
  }

  // Quiescence search: only consider captures to stabilize evaluation
  function quiescence(alpha, beta, deadline){
    const stand = evaluate();
    if (stand >= beta) return beta;
    if (alpha < stand) alpha = stand;

    const caps = [];
    for (let y=0;y<10;y++){
      for (let x=0;x<9;x++){
        const p=board[y][x];
        if (!p || p.c!==sideToMove) continue;
        const moves = generatePseudoMovesFor(x,y,p);
        for (const m of moves){
          if (m.capture){
            const cap = makeMove(m);
            const legal = !isInCheck(toggleSide(sideToMove)); // after makeMove, sideToMove toggled
            undoMove(m,cap);
            if (legal) caps.push(m);
          }
        }
      }
    }
    // Simple MVV-LVA ordering: higher captured value first
    caps.sort((a,b)=> (VAL[b.capture?.t||'S']||0) - (VAL[a.capture?.t||'S']||0));

    for (const m of caps){
      if (performance.now() > deadline) break;
      const cap = makeMove(m);
      const score = -quiescence(-beta, -alpha, deadline);
      undoMove(m, cap);
      if (score >= beta) return beta;
      if (score > alpha) alpha = score;
    }
    return alpha;
  }

  // Rendering
  let svg = null, gGrid=null, gHints=null, gPieces=null, gOverlay=null, gCoords=null;
  function initSVG(){
    svg = svgEl('svg', { viewBox:`0 0 ${VB_W} ${VB_H}`, role:'img', 'aria-label':'Xiangqi board' });
    elWrap.innerHTML = '';
    elWrap.appendChild(svg);

    gGrid = svgEl('g', {});
    gHints = svgEl('g', {});
    gPieces = svgEl('g', {});
    gOverlay = svgEl('g', {});
    gCoords = svgEl('g', {});
    svg.appendChild(gGrid);
    svg.appendChild(gHints);
    svg.appendChild(gPieces);
    svg.appendChild(gOverlay);
    svg.appendChild(gCoords);

    drawGrid();
    drawRiverText();
    drawCoords();
    drawAllPieces();
    updateStatus();
  }

  function svgEl(tag, attrs, children=[]){
    const e = document.createElementNS('http://www.w3.org/2000/svg', tag);
    for (const [k,v] of Object.entries(attrs||{})){
      e.setAttribute(k,String(v));
    }
    for (const ch of children) e.appendChild(ch);
    return e;
  }
  function cellToXY(x,y){
    // Map board cells to viewBox coords
    const gx = BOARD_X0 + x*CELL;
    const gy = BOARD_Y0 + y*CELL;
    return [gx, gy];
  }

  function drawGrid(){
    gGrid.innerHTML = '';
    // Outer border
    gGrid.appendChild(svgEl('rect', {x:BOARD_X0, y:BOARD_Y0, width: (9-1)*CELL, height:(10-1)*CELL, fill:'none', class:'grid-line'}));
    // Horizontal lines
    for (let r=0;r<10;r++){
      const [x0,y] = cellToXY(0,r);
      const [x8,_] = cellToXY(8,r);
      if (r===4 || r===5){
        // split at river
        gGrid.appendChild(svgEl('line', {x1:x0,y1:y,x2:x0+(4*CELL),y2:y, class:'grid-line'}));
        gGrid.appendChild(svgEl('line', {x1:x0+(5*CELL),y1:y,x2:x8,y2:y, class:'grid-line'}));
      } else {
        gGrid.appendChild(svgEl('line', {x1:x0,y1:y,x2:x8,y2:y, class:'grid-line'}));
      }
    }
    // Vertical lines
    for (let c=0;c<9;c++){
      const [x,y0] = cellToXY(c,0);
      const [_,y9] = cellToXY(c,9);
      gGrid.appendChild(svgEl('line', {x1:x,y1:y0,x2:x,y2:y9, class:'grid-line'}));
    }
    // Palaces X
    const palace = (y0) => {
      const [x3,yA] = cellToXY(3,y0);
      const [x5,yB] = cellToXY(5,y0+2);
      const [x5b,yA2] = cellToXY(5,y0);
      const [x3b,yB2] = cellToXY(3,y0+2);
      gGrid.appendChild(svgEl('line', {x1:x3,y1:yA,x2:x5,y2:yB,class:'grid-line'}));
      gGrid.appendChild(svgEl('line', {x1:x5b,y1:yA,x2:x3b,y2:yB2,class:'grid-line'}));
    };
    palace(0); palace(7);
  }

  function drawRiverText(){
    const [x0,y4] = cellToXY(0,4);
    const [x8,y5] = cellToXY(8,5);
    const midX = (x0 + x8) / 2;
    const midY = (y4 + y5) / 2;
    const text = svgEl('text', {x: midX, y: midY, class:'river-text'});
    text.textContent = '楚河    漢界';
    text.setAttribute('text-anchor','middle');
    gGrid.appendChild(text);
  }

  function drawCoords(){
    gCoords.innerHTML = '';
    for (let x=0;x<9;x++){
      const [gx,gyTop] = cellToXY(x,0);
      const [_,gyBot] = cellToXY(x,9);
      const tTop = svgEl('text', {x: gx, y: gyTop - 2.2, class:'coords'});
      tTop.textContent = String.fromCharCode(65+x); // A..I
      tTop.setAttribute('text-anchor','middle');
      const tBot = svgEl('text', {x: gx, y: gyBot + 2.8, class:'coords'});
      tBot.textContent = (x+1);
      tBot.setAttribute('text-anchor','middle');
      gCoords.appendChild(tTop);
      gCoords.appendChild(tBot);
    }
  }

  function drawAllPieces(){
    gPieces.innerHTML = '';
    gHints.innerHTML = '';
    for (let y=0;y<10;y++){
      for (let x=0;x<9;x++){
        const p = board[y][x];
        if (!p) continue;
        drawPiece(x,y,p);
      }
    }
    if (selected) drawSelectionAndHints();
  }

  function drawPiece(x,y,p){
    const [gx,gy] = cellToXY(x,y);
    const g = svgEl('g', {class:`piece ${p.c===RED?'p-red':'p-black'}`, 'data-x':x, 'data-y':y});
    const r = 4.2;
    g.appendChild(svgEl('circle', {cx:gx, cy:gy, r, class:'p-circle'}));
    const t = svgEl('text', {x:gx, y:gy+0.3, class:'p-label'});
    t.textContent = LABELS[p.t][p.c];
    g.appendChild(t);
    g.addEventListener('click', onCellClickFromPiece);
    g.addEventListener('touchstart', onCellClickFromPiece, {passive:true});
    gPieces.appendChild(g);
  }

  function drawSelectionAndHints(){
    gHints.innerHTML = '';
    const {x,y} = selected;
    const [gx,gy] = cellToXY(x,y);
    gHints.appendChild(svgEl('rect', {x:gx-4.6, y:gy-4.6, width:9.2, height:9.2, rx:1.2, ry:1.2, class:'sel'}));
    for (const m of legalMovesFromSel){
      const [hx,hy] = cellToXY(m.tx,m.ty);
      gHints.appendChild(svgEl('circle', {cx:hx, cy:hy, r:1.4, class:'hint'}));
    }
  }

  function onCellClickFromPiece(e){
    const g = e.currentTarget;
    const x = parseInt(g.getAttribute('data-x'),10);
    const y = parseInt(g.getAttribute('data-y'),10);
    onCellClick(x,y);
  }

  // Background click to move to empty square
  svgClickSetup();
  function svgClickSetup(){
    elWrap.addEventListener('click', (e)=>{
      const pt = pointToCell(e);
      if (!pt) return;
      onCellClick(pt.x, pt.y);
    });
    elWrap.addEventListener('touchstart', (e)=>{
      const touch = e.touches[0];
      const pt = pointToCell(touch);
      if (!pt) return;
      onCellClick(pt.x, pt.y);
    }, {passive:true});
  }
  function pointToCell(evt){
    if (!svg) return null;
    const rect = svg.getBoundingClientRect();
    const px = ((evt.clientX - rect.left)/rect.width) * VB_W;
    const py = ((evt.clientY - rect.top)/rect.height) * VB_H;
    // snap to nearest cell center
    const x = Math.round((px - BOARD_X0)/CELL);
    const y = Math.round((py - BOARD_Y0)/CELL);
    if (!inBoard(x,y)) return null;
    return {x,y};
  }

  function onCellClick(x,y){
    if (gameOver || searching) return;
    const p = board[y][x];
    const myTurn = sideToMove === humanSide;
    // If no selection: must select own piece
    if (!selected){
      if (!myTurn) return;
      if (!p || p.c !== humanSide) return;
      selected = {x,y};
      legalMovesFromSel = legalMovesFrom(x,y);
      drawAllPieces();
      return;
    }
    // If selecting same color piece, reselect
    if (p && p.c === humanSide){
      selected = {x,y};
      legalMovesFromSel = legalMovesFrom(x,y);
      drawAllPieces();
      return;
    }
    // Attempt move if legal
    const mv = legalMovesFromSel.find(m => m.tx===x && m.ty===y);
    if (mv){
      moveAndAdvance(mv);
    } else {
      // click empty illegal -> clear selection
      selected = null;
      legalMovesFromSel = [];
      drawAllPieces();
    }
  }

  function legalMovesFrom(x,y){
    const p = board[y][x];
    if (!p) return [];
    const all = generateLegalMoves(p.c);
    return all.filter(m => m.fx===x && m.fy===y);
  }

  function moveAndAdvance(mv){
    if (gameOver) return;
    // Make move
    const cap = makeMove(mv);
    history.push({move: mv, captured: cap});
    selected = null;
    legalMovesFromSel = [];
    drawAllPieces();

    // Check game end
    const opp = sideToMove;
    const oppMoves = generateLegalMoves(opp);
    if (oppMoves.length===0){
      const mate = isInCheck(opp);
      gameOver = true;
      updateStatus(mate ? (humanSide===opp ? 'You are checkmated.' : 'You delivered checkmate!') : 'Stalemate.');
      return;
    }

    updateStatus();
    // If AI turn, think
    if (sideToMove !== humanSide){
      searching = true;
      updateStatus('AI is thinking...');
      setTimeout(()=> {
        const res = searchRoot(aiTimeMs);
        searching = false;
        if (!res.move){
          gameOver = true;
          updateStatus('Game over.');
          return;
        }
        const cap2 = makeMove(res.move);
        history.push({move: res.move, captured: cap2});
        drawAllPieces();
        // Check end again
        const humanMoves = generateLegalMoves(humanSide);
        if (humanMoves.length===0){
          const mate = isInCheck(humanSide);
          gameOver = true;
          updateStatus(mate ? 'Checkmated. Good game.' : 'Stalemate.');
          return;
        }
        updateStatus();
      }, 20);
    }
  }

  function updateStatus(text){
    if (text){
      elStatus.textContent = text;
      return;
    }
    if (gameOver) return;
    const stm = sideToMove===RED ? 'Red' : 'Black';
    const you = humanSide===RED ? 'Red' : 'Black';
    const check = isInCheck(sideToMove) ? ' (in check)' : '';
    if (sideToMove === humanSide){
      elStatus.textContent = `Your move as ${you}${check}.`;
    } else {
      elStatus.textContent = `AI to move as ${stm}${check}.`;
    }
  }

  // Controls
  newBtn.addEventListener('click', ()=>{
    board = startPosition();
    sideToMove = RED;
    history = [];
    gameOver = false;
    selected = null;
    legalMovesFromSel = [];
    TT.clear();
    hash = computeHash(board, sideToMove);
    drawAllPieces();
    updateStatus(`Your move as ${humanSide===RED?'Red':'Black'}.`);
    // If AI is to move immediately
    if (sideToMove !== humanSide){
      setTimeout(()=> onCellClick(-1,-1), 10);
      if (!searching){
        searching = true; updateStatus('AI is thinking...');
        setTimeout(()=> {
          const res = searchRoot(aiTimeMs);
          searching = false;
          if (res.move){
            const cap2 = makeMove(res.move);
            history.push({move: res.move, captured: cap2});
            drawAllPieces(); updateStatus();
          }
        }, 10);
      }
    }
  });

  switchBtn.addEventListener('click', ()=>{
    if (searching) return;
    humanSide = toggleSide(humanSide);
    updateStatus(`You now play ${humanSide===RED?'Red':'Black'}.`);
    drawAllPieces();
    if (sideToMove !== humanSide && !gameOver){
      searching = true; updateStatus('AI is thinking...');
      setTimeout(()=> {
        const res = searchRoot(aiTimeMs);
        searching = false;
        if (res.move){
          const cap2 = makeMove(res.move);
          history.push({move: res.move, captured: cap2});
        }
        drawAllPieces();
        updateStatus();
      }, 25);
    }
  });

  undoBtn.addEventListener('click', ()=>{
    if (searching || history.length===0) return;
    // Undo one ply (AI) if AI moved last, else undo one ply (human)
    const last = history.pop();
    undoMove(last.move, last.captured);
    // If now it's opponent's move relative to human, undo one more to return to human to move
    if (sideToMove !== humanSide && history.length>0){
      const last2 = history.pop();
      undoMove(last2.move, last2.captured);
    }
    gameOver = false;
    selected = null; legalMovesFromSel = [];
    drawAllPieces();
    updateStatus();
  });

  timeRange.addEventListener('input', ()=>{
    aiTimeMs = parseInt(timeRange.value,10);
    timeLabel.textContent = `${(aiTimeMs/1000).toFixed(1)}s/move`;
  });

  // Initialize
  initSVG();

})();
</script>
</body>
</html>
