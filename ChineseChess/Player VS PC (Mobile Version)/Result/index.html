<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Xiangqi — Mobile-first Web Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root{
      --bg:#111316;
      --panel:#171a1f;
      --accent:#ff4d4f;
      --accent-muted:#ffb3b4;
      --ink:#e6e8eb;
      --muted:#a2a8b3;
      --board:#f8e9c9;
      --board-line:#5b432c;
      --red:#d8413f;
      --black:#1e1e1e;
      --green:#18a058;
      --yellow:#e6a700;
    }
    *{box-sizing:border-box;}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,Apple Color Emoji,Segoe UI Emoji;line-height:1.4;}
    .wrap{
      max-width:900px;
      margin:0 auto;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    header{
      display:flex;align-items:center;justify-content:space-between;
      gap:8px;flex-wrap:wrap;
    }
    h1{font-size:18px;margin:0;color:var(--ink);font-weight:600;letter-spacing:.2px}
    .controls{
      background:var(--panel);
      border-radius:12px;
      padding:10px;
      display:flex;flex-wrap:wrap;gap:10px;align-items:center;
    }
    .controls label{font-size:12px;color:var(--muted)}
    .controls select,.controls button,.controls input[type="range"]{
      background:#0f1216;border:1px solid #252a31;color:var(--ink);
      padding:8px 10px;border-radius:10px;font-size:14px;
    }
    .controls button{
      cursor:pointer;border:1px solid #2a313b;
    }
    .controls button.primary{background:var(--accent);border-color:var(--accent);color:white}
    .controls .group{display:flex;align-items:center;gap:8px}
    .status{
      font-size:14px;color:var(--accent-muted);
      padding:6px 0 2px 2px;min-height:22px;
    }

    .board-wrap{
      background:var(--panel);
      border-radius:16px;
      padding:10px;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      touch-action:none;
      border-radius:12px;
      background:var(--board);
    }
    footer{color:var(--muted);font-size:12px;padding:3px 2px 12px}
    /* Make buttons larger on mobile */
    @media (max-width:480px){
      .controls select,.controls button{font-size:15px;padding:10px 12px}
      .controls input[type="range"]{width:120px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Chinese Chess (Xiangqi)</h1>
      <div class="controls">
        <div class="group">
          <label for="side">Your side</label>
          <select id="side">
            <option value="r">Red (moves first)</option>
            <option value="b">Black</option>
          </select>
        </div>
        <div class="group">
          <label for="depth">AI depth</label>
          <input id="depth" type="range" min="1" max="4" step="1" value="2" />
          <span id="depthLabel">2</span>
        </div>
        <div class="group">
          <button id="new" class="primary">New game</button>
          <button id="undo">Undo</button>
        </div>
      </div>
    </header>

    <div class="status" id="status">Ready.</div>

    <div class="board-wrap">
      <canvas id="board" width="900" height="1012"></canvas>
    </div>

    <footer>
      Tip: Tap a piece to see legal moves. Tap again to deselect. Long-press on empty to clear selection.
    </footer>
  </div>

  <script>
  (() => {
    // Piece notation: uppercase = Red, lowercase = Black
    // K/A/E/H/R/C/S  (General, Advisor, Elephant, Horse, Rook, Cannon, Soldier)
    // Board: 10 rows x 9 cols. row 0 is Black back rank; row 9 is Red back rank.
    const EMPTY = '.';
    const START_POS = [
      ['r','h','e','a','k','a','e','h','r'],
      ['.','.','.','.','.','.','.','.','.'],
      ['.','c','.','.','.','.','.','c','.'],
      ['s','.','s','.','s','.','s','.','s'],
      ['.','.','.','.','.','.','.','.','.'],
      ['.','.','.','.','.','.','.','.','.'],
      ['S','.','S','.','S','.','S','.','S'],
      ['.','C','.','.','.','.','.','C','.'],
      ['.','.','.','.','.','.','.','.','.'],
      ['R','H','E','A','K','A','E','H','R'],
    ];

    // UI state
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const sideSel = document.getElementById('side');
    const newBtn = document.getElementById('new');
    const undoBtn = document.getElementById('undo');
    const depthInput = document.getElementById('depth');
    const depthLabel = document.getElementById('depthLabel');

    // DPR-aware sizing
    function resizeCanvas() {
      // Maintain square cells: width intervals = 8, height intervals = 9, so height = width * 9/8
      const cssWidth = Math.min(document.querySelector('.board-wrap').clientWidth - 20, 900);
      const cssHeight = Math.round(cssWidth * 9 / 8 + 12); // small border for palace diagonals
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.style.width = cssWidth + 'px';
      canvas.style.height = cssHeight + 'px';
      canvas.width = Math.floor(cssWidth * dpr);
      canvas.height = Math.floor(cssHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      draw();
    }
    window.addEventListener('resize', () => {
      resizeCanvas();
    });

    // Game state
    let board = cloneBoard(START_POS);
    let sideToMove = 'r'; // 'r' or 'b'
    let humanSide = 'r';
    let selected = null; // {r,c}
    let movesForSelected = [];
    let history = []; // stack of {from:{r,c}, to:{r,c}, captured, prevSTM}
    let gameOver = false;
    let aiThinking = false;
    let aiDepth = parseInt(depthInput.value, 10);

    // Colors / styling
    const COLORS = {
      board: getComputedStyle(document.documentElement).getPropertyValue('--board').trim(),
      line: getComputedStyle(document.documentElement).getPropertyValue('--board-line').trim(),
      red: getComputedStyle(document.documentElement).getPropertyValue('--red').trim(),
      black: getComputedStyle(document.documentElement).getPropertyValue('--black').trim(),
      hl: getComputedStyle(document.documentElement).getPropertyValue('--green').trim(),
      danger: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim(),
      ghost: 'rgba(24,160,88,0.2)',
    };

    function cloneBoard(b) {
      return b.map(row => row.slice());
    }

    function isUpper(ch){ return ch !== EMPTY && ch === ch.toUpperCase(); }
    function sideOf(ch){ return isUpper(ch) ? 'r' : 'b'; }

    function opposite(side){ return side === 'r' ? 'b' : 'r'; }

    function inside(r,c){ return r>=0 && r<10 && c>=0 && c<9; }

    function inPalace(side, r, c){
      if(side === 'r') return r>=7 && r<=9 && c>=3 && c<=5;
      return r>=0 && r<=2 && c>=3 && c<=5;
    }

    function sameSide(a,b){
      if(a===EMPTY || b===EMPTY) return false;
      return sideOf(a) === sideOf(b);
    }

    // Draw board and pieces
    function draw(){
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);

      const margin = 12;
      const gridW = w - margin*2;
      const cell = gridW / 8; // 9 files -> 8 intervals
      const gridH = cell * 9;
      const top = (h - gridH)/2;
      const left = margin;

      // Save geometry for hit-tests
      geom.cell = cell; geom.left = left; geom.top = top;

      // Board background
      ctx.fillStyle = COLORS.board;
      ctx.fillRect(0,0,w,h);

      // Grid lines
      ctx.strokeStyle = COLORS.line;
      ctx.lineWidth = 1.5;
      ctx.lineCap = 'square';
      ctx.beginPath();
      // Horizontal lines (10 ranks => draw 10 lines)
      for(let r=0;r<10;r++){
        const y = top + r*cell;
        ctx.moveTo(left, y);
        ctx.lineTo(left + 8*cell, y);
      }
      // Vertical lines (9 files => draw 9 columns, with river gap)
      for(let c=0;c<9;c++){
        const x = left + c*cell;
        // top half
        ctx.moveTo(x, top);
        ctx.lineTo(x, top + 4*cell);
        // bottom half
        ctx.moveTo(x, top + 5*cell);
        ctx.lineTo(x, top + 9*cell);
      }
      ctx.stroke();

      // Palace diagonals
      ctx.beginPath();
      // Black palace (top)
      ctx.moveTo(left + 3*cell, top);
      ctx.lineTo(left + 5*cell, top + 2*cell);
      ctx.moveTo(left + 5*cell, top);
      ctx.lineTo(left + 3*cell, top + 2*cell);
      // Red palace (bottom)
      ctx.moveTo(left + 3*cell, top + 7*cell);
      ctx.lineTo(left + 5*cell, top + 9*cell);
      ctx.moveTo(left + 5*cell, top + 7*cell);
      ctx.lineTo(left + 3*cell, top + 9*cell);
      ctx.stroke();

      // "River"
      ctx.fillStyle = 'rgba(0,0,0,0.06)';
      ctx.fillRect(left, top + 4*cell, 8*cell, cell);
      ctx.fillStyle = '#8c6b3b';
      ctx.font = `${Math.floor(cell*0.34)}px serif`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('楚河', left + 2*cell, top + 4.5*cell);
      ctx.fillText('漢界', left + 6*cell, top + 4.5*cell);

      // Highlights for legal moves
      if (selected) {
        // from square
        drawSquareHighlight(selected.r, selected.c, COLORS.ghost);
        for (const m of movesForSelected) {
          drawMoveDot(m.to.r, m.to.c, board[m.to.r][m.to.c] === EMPTY ? COLORS.hl : COLORS.danger);
        }
      }

      // Check highlight on side to move's general if in check
      const kpos = findKing(board, sideToMove);
      if (kpos && inCheck(board, sideToMove)) {
        drawSquareRing(kpos.r, kpos.c, COLORS.danger);
      }

      // Pieces
      for(let r=0;r<10;r++){
        for(let c=0;c<9;c++){
          const p = board[r][c];
          if(p!==EMPTY) drawPiece(r,c,p);
        }
      }
    }

    function drawSquareHighlight(r,c, color){
      const {left,top,cell} = geom;
      ctx.fillStyle = color;
      ctx.fillRect(left + c*cell - 2, top + r*cell - 2, cell + 4, cell + 4);
    }
    function drawSquareRing(r,c, color){
      const {left,top,cell} = geom;
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      ctx.strokeRect(left + c*cell + 3, top + r*cell + 3, cell - 6, cell - 6);
    }
    function drawMoveDot(r,c,color){
      const {left,top,cell} = geom;
      ctx.beginPath();
      ctx.fillStyle = color;
      // If capture, draw ring; if empty, draw solid dot
      if(board[r][c] === EMPTY){
        ctx.arc(left + c*cell + cell/2, top + r*cell + cell/2, Math.min(8, cell*0.12), 0, Math.PI*2);
        ctx.fill();
      } else {
        ctx.lineWidth = 3;
        ctx.strokeStyle = color;
        ctx.arc(left + c*cell + cell/2, top + r*cell + cell/2, Math.min(12, cell*0.2), 0, Math.PI*2);
        ctx.stroke();
      }
    }

    function drawPiece(r,c,p){
      const {left,top,cell} = geom;
      const x = left + c*cell + cell/2;
      const y = top + r*cell + cell/2;

      // Piece disc
      ctx.beginPath();
      ctx.fillStyle = '#fffdf6';
      ctx.strokeStyle = '#b59a78';
      ctx.lineWidth = 3;
      ctx.arc(x,y, cell*0.38, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // Inner ring
      ctx.beginPath();
      ctx.strokeStyle = '#c3ad8f';
      ctx.lineWidth = 1.5;
      ctx.arc(x,y, cell*0.30, 0, Math.PI*2);
      ctx.stroke();

      // Text
      const red = isUpper(p);
      ctx.fillStyle = red ? COLORS.red : COLORS.black;
      ctx.font = `600 ${Math.floor(cell*0.34)}px 'Noto Serif SC', 'STKaiti', 'KaiTi', serif`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(pieceGlyph(p), x, y + 1);
    }

    function pieceGlyph(p){
      switch(p.toUpperCase()){
        case 'R': return '車';
        case 'H': return '馬';
        case 'E': return isUpper(p)?'相':'象';
        case 'A': return isUpper(p)?'仕':'士';
        case 'K': return isUpper(p)?'帥':'將';
        case 'C': return '炮';
        case 'S': return isUpper(p)?'兵':'卒';
      }
      return '?';
    }

    // Geometry cache for draw/hit
    const geom = {left:0, top:0, cell:90};

    function posFromXY(x,y){
      const {left,top,cell} = geom;
      const c = Math.floor((x - left)/cell);
      const r = Math.floor((y - top)/cell);
      if(inside(r,c)) return {r,c};
      return null;
    }

    // Input handling
    canvas.addEventListener('mousedown', onPointerDown);
    canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); onPointerDown(e.touches[0]); }, {passive:false});

    function onPointerDown(e){
      if (gameOver || aiThinking) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left);
      const y = (e.clientY - rect.top);
      const pos = posFromXY(x,y);
      if(!pos) return;

      const p = board[pos.r][pos.c];
      const myTurn = sideToMove === humanSide;

      // If selecting/deselecting
      if(selected && selected.r === pos.r && selected.c === pos.c){
        clearSelection();
        draw(); return;
      }

      if(selected){
        // Try move if legal
        const legal = movesForSelected.find(m => m.to.r === pos.r && m.to.c === pos.c);
        if(legal && myTurn){
          makeMove(legal);
          clearSelection();
          draw();
          afterHumanMove();
          return;
        }
      }

      // New selection
      if(p !== EMPTY && sideOf(p) === humanSide && myTurn){
        selected = pos;
        movesForSelected = generateLegalMovesForSquare(board, pos.r, pos.c, sideToMove);
        draw();
      } else {
        clearSelection();
        draw();
      }
    }

    function clearSelection(){
      selected = null;
      movesForSelected = [];
    }

    // Move representation: {from:{r,c}, to:{r,c}, piece, captured}
    function makeMove(m){
      history.push({from:m.from, to:m.to, captured:m.captured, piece:m.piece, prevSTM: sideToMove});
      board[m.to.r][m.to.c] = m.piece;
      board[m.from.r][m.from.c] = EMPTY;
      sideToMove = opposite(sideToMove);
      updateStatus();
    }

    function unmakeMove(){
      const h = history.pop();
      if(!h) return;
      board[h.from.r][h.from.c] = h.piece;
      board[h.to.r][h.to.c] = h.captured || EMPTY;
      sideToMove = h.prevSTM;
      updateStatus();
    }

    undoBtn.addEventListener('click', ()=>{
      if (aiThinking) return;
      // Undo human + AI moves (if available)
      unmakeMove();
      if (sideToMove !== humanSide) unmakeMove();
      gameOver = false;
      clearSelection();
      draw();
    });

    newBtn.addEventListener('click', ()=>{
      resetGame();
    });

    sideSel.addEventListener('change', ()=>{
      humanSide = sideSel.value;
      resetGame();
    });

    depthInput.addEventListener('input', ()=>{
      aiDepth = parseInt(depthInput.value, 10);
      depthLabel.textContent = aiDepth;
    });

    function resetGame(){
      board = cloneBoard(START_POS);
      sideToMove = 'r';
      clearSelection();
      history = [];
      gameOver = false;
      aiThinking = false;
      updateStatus();
      draw();
      // If AI is Red and moves first
      if (humanSide === 'b') {
        aiMoveSoon();
      }
    }

    function updateStatus(){
      if(gameOver){
        statusEl.textContent = winnerText || 'Game over.';
        return;
      }
      const stm = sideToMove === 'r' ? 'Red' : 'Black';
      const you = humanSide === sideToMove ? 'Your move.' : 'Computer is thinking...';
      statusEl.textContent = `${stm} to move. ${you}`;
    }

    function afterHumanMove(){
      // Check end
      if (isCheckmate(board, sideToMove)) {
        gameOver = true;
        winnerText = humanSide === opposite(sideToMove) ? 'You win by checkmate!' : 'Checkmate. You lose.';
        updateStatus(); draw(); return;
      }
      if (isStalemate(board, sideToMove)) {
        gameOver = true; winnerText = 'Stalemate.'; updateStatus(); draw(); return;
      }
      aiMoveSoon();
    }

    function aiMoveSoon(){
      if (gameOver) return;
      aiThinking = true;
      updateStatus();
      // Allow UI to update
      setTimeout(()=>{
        const m = findBestMove(board, sideToMove, aiDepth);
        if (m) {
          makeMove(m);
          draw();
          // End checks
          if (isCheckmate(board, sideToMove)) {
            gameOver = true;
            winnerText = humanSide === opposite(sideToMove) ? 'Computer wins by checkmate.' : 'You win by checkmate!';
          } else if (isStalemate(board, sideToMove)) {
            gameOver = true;
            winnerText = 'Stalemate.';
          } else {
            winnerText = '';
          }
        } else {
          gameOver = true;
          winnerText = 'No legal moves.';
        }
        aiThinking = false;
        updateStatus();
        draw();
      }, 50);
    }

    let winnerText = '';

    // Move generation
    function generateLegalMoves(board, side){
      const moves = [];
      for(let r=0;r<10;r++){
        for(let c=0;c<9;c++){
          const p = board[r][c];
          if(p===EMPTY) continue;
          if(sideOf(p) !== side) continue;
          const pseudo = generatePseudoMoves(board, r, c);
          for(const m of pseudo){
            if (isLegalMove(board, m, side)) moves.push(m);
          }
        }
      }
      return moves;
    }

    function generateLegalMovesForSquare(board, r, c, side){
      const p = board[r][c];
      if(p===EMPTY || sideOf(p)!==side) return [];
      const pseudo = generatePseudoMoves(board, r, c);
      return pseudo.filter(m => isLegalMove(board, m, side));
    }

    function isLegalMove(board, m, side){
      // Apply, test for check (own king must not be in check), also enforce flying general rule
      applyTemp(board, m);
      const ok = !inCheck(board, side);
      undoTemp(board, m);
      return ok;
    }

    function generatePseudoMoves(board, r, c){
      const p = board[r][c];
      if (p===EMPTY) return [];
      const side = sideOf(p);
      const res = [];
      const add = (tr,tc)=>{
        if(!inside(tr,tc)) return false;
        const t = board[tr][tc];
        if (t===EMPTY || sideOf(t)!==side) {
          res.push({from:{r,c}, to:{r:tr,c:tc}, piece:p, captured: t===EMPTY?null:t});
          return t===EMPTY; // continue only if empty (for sliders)
        }
        return false;
      };

      const forward = (side==='r') ? -1 : 1;

      switch(p.toUpperCase()){
        case 'K': {
          // orthogonal 1 within palace + flying general capture
          const cand = [[1,0],[-1,0],[0,1],[0,-1]];
          for(const [dr,dc] of cand){
            const tr = r+dr, tc = c+dc;
            if (inside(tr,tc) && inPalace(side,tr,tc)) add(tr,tc);
          }
          // flying general capture: along file if no piece in between
          const oppK = findKing(board, opposite(side));
          if(oppK && c===oppK.c){
            let blocked = false;
            const step = (oppK.r > r) ? 1 : -1;
            for(let rr = r+step; rr !== oppK.r; rr += step){
              if(board[rr][c] !== EMPTY){ blocked = true; break; }
            }
            if(!blocked){
              // Can "capture" opposing general if move lands there (but in Xiangqi, generals cannot move off palace; here we model it via capture only if adjacent? Simplify: allow only if one step move places on general square while path clear).
              const tr = r + step;
              if (tr === oppK.r && inPalace(side,tr,c)) add(tr,c);
            }
          }
          break;
        }
        case 'A': {
          // diagonals 1 within palace
          const cand = [[1,1],[1,-1],[-1,1],[-1,-1]];
          for(const [dr,dc] of cand){
            const tr = r+dr, tc = c+dc;
            if(inside(tr,tc) && inPalace(side,tr,tc)) add(tr,tc);
          }
          break;
        }
        case 'E': {
          // diagonals 2, cannot cross river, elephant eye must be empty
          const cand = [[2,2],[2,-2],[-2,2],[-2,-2]];
          for(const [dr,dc] of cand){
            const tr = r+dr, tc = c+dc;
            const mr = r+dr/2, mc = c+dc/2;
            if(!inside(tr,tc)) continue;
            // river: Red elephants must stay r>=5, Black elephants r<=4
            if (side==='r' ? (tr<5) : (tr>4)) continue;
            if(board[mr][mc]!==EMPTY) continue; // elephant eye
            add(tr,tc);
          }
          break;
        }
        case 'H': {
          // horse: 1 orth then 1 diag; horse leg must be empty
          const steps = [
            {to:[-2,-1], block:[-1,0]},
            {to:[-2, 1], block:[-1,0]},
            {to:[ 2,-1], block:[ 1,0]},
            {to:[ 2, 1], block:[ 1,0]},
            {to:[-1,-2], block:[0,-1]},
            {to:[ 1,-2], block:[0,-1]},
            {to:[-1, 2], block:[0, 1]},
            {to:[ 1, 2], block:[0, 1]},
          ];
          for(const s of steps){
            const tr = r + s.to[0], tc = c + s.to[1];
            const br = r + s.block[0], bc = c + s.block[1];
            if(!inside(tr,tc) || !inside(br,bc)) continue;
            if(board[br][bc] !== EMPTY) continue; // blocked leg
            add(tr,tc);
          }
          break;
        }
        case 'R': {
          // rook: orthogonal sliders
          // up
          for(let tr=r-1; tr>=0; tr--){
            if(!add(tr,c)) break;
          }
          // down
          for(let tr=r+1; tr<10; tr++){
            if(!add(tr,c)) break;
          }
          // left
          for(let tc=c-1; tc>=0; tc--){
            if(!add(r,tc)) break;
          }
          // right
          for(let tc=c+1; tc<9; tc++){
            if(!add(r,tc)) break;
          }
          break;
        }
        case 'C': {
          // cannon: moves like rook without capture; to capture must jump exactly one screen
          // For each direction: first push non-captures until a piece, then look for first piece beyond to capture
          const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
          for(const [dr,dc] of dirs){
            let tr = r + dr, tc = c + dc;
            // Non-captures
            while(inside(tr,tc) && board[tr][tc]===EMPTY){
              res.push({from:{r,c}, to:{r:tr,c:tc}, piece:p, captured:null});
              tr += dr; tc += dc;
            }
            // Now find one screen
            while(inside(tr,tc) && board[tr][tc]===EMPTY){
              tr += dr; tc += dc;
            }
            if(inside(tr,tc) && board[tr][tc]!==EMPTY){
              // found screen at tr,tc; now next non-empty to capture
              tr += dr; tc += dc;
              while(inside(tr,tc) && board[tr][tc]===EMPTY){
                tr += dr; tc += dc;
              }
              if(inside(tr,tc) && board[tr][tc]!==EMPTY && sideOf(board[tr][tc])!==side){
                res.push({from:{r,c}, to:{r:tr,c:tc}, piece:p, captured:board[tr][tc]});
              }
            }
          }
          break;
        }
        case 'S': {
          // soldier: forward 1; after crossing river also left/right; never backward
          const tr = r + forward, tc = c;
          if(inside(tr,tc)) add(tr,tc);
          const crossed = side==='r' ? (r<=4) : (r>=5);
          if(crossed){
            if(inside(r, c-1)) add(r, c-1);
            if(inside(r, c+1)) add(r, c+1);
          }
          break;
        }
      }
      // Filter out illegal "flying general" exposures: already covered in isLegalMove via inCheck
      return res;
    }

    function applyTemp(board, m){
      board[m.to.r][m.to.c] = m.piece;
      board[m.from.r][m.from.c] = EMPTY;
    }
    function undoTemp(board, m){
      board[m.from.r][m.from.c] = m.piece;
      board[m.to.r][m.to.c] = m.captured || EMPTY;
    }

    function findKing(board, side){
      const target = side==='r' ? 'K' : 'k';
      for(let r=0;r<10;r++){
        for(let c=0;c<9;c++){
          if(board[r][c]===target) return {r,c};
        }
      }
      return null;
    }

    function inCheck(board, side){
      const k = findKing(board, side);
      if(!k) return false; // should not happen
      const r = k.r, c = k.c;
      const opp = opposite(side);

      // 1) Soldiers
      const fwd = (opp==='r') ? -1 : 1;
      const soldierThreats = [
        {r:r+fwd, c:c}, // soldier forward towards our king
        {r:r, c:c-1},
        {r:r, c:c+1},
      ];
      for(const s of soldierThreats){
        if(inside(s.r,s.c)){
          const p = board[s.r][s.c];
          if(p!==EMPTY && sideOf(p)===opp && p.toUpperCase()==='S'){
            // Sideways only if that soldier has crossed river
            if (s.r !== r) return true; // forward attack is always allowed
            // sideways: ensure attacker crossed river (relative to its side)
            const crossed = (opp==='r') ? (s.r<=4) : (s.r>=5);
            if (crossed) return true;
          }
        }
      }

      // 2) Horses (with leg rule)
      const horseSteps = [
        {to:[-2,-1], block:[-1,0]},
        {to:[-2, 1], block:[-1,0]},
        {to:[ 2,-1], block:[ 1,0]},
        {to:[ 2, 1], block:[ 1,0]},
        {to:[-1,-2], block:[0,-1]},
        {to:[ 1,-2], block:[0,-1]},
        {to:[-1, 2], block:[0, 1]},
        {to:[ 1, 2], block:[0, 1]},
      ];
      for(const s of horseSteps){
        const sr = r - s.to[0], sc = c - s.to[1]; // attacker position
        const br = sr + s.block[0], bc = sc + s.block[1];
        if(inside(sr,sc) && inside(br,bc)){
          const p = board[sr][sc];
          if(p!==EMPTY && sideOf(p)===opp && p.toUpperCase()==='H'){
            if(board[br][bc]===EMPTY) return true;
          }
        }
      }

      // 3) Rooks and Generals along ranks/files (no blockers)
      // Up
      for(let tr=r-1; tr>=0; tr--){
        const p = board[tr][c];
        if(p===EMPTY) continue;
        if(sideOf(p)===opp){
          const upc = p.toUpperCase();
          if(upc==='R') return true;
          // Flying general
          if(upc==='K'){
            // ensure no blockers: we already hit it first so ok
            return true;
          }
          break;
        } else break;
      }
      // Down
      for(let tr=r+1; tr<10; tr++){
        const p = board[tr][c];
        if(p===EMPTY) continue;
        if(sideOf(p)===opp){
          const upc = p.toUpperCase();
          if(upc==='R') return true;
          if(upc==='K') return true;
          break;
        } else break;
      }
      // Left
      for(let tc=c-1; tc>=0; tc--){
        const p = board[r][tc];
        if(p===EMPTY) continue;
        if(sideOf(p)===opp){
          const upc = p.toUpperCase();
          if(upc==='R') return true;
          break;
        } else break;
      }
      // Right
      for(let tc=c+1; tc<9; tc++){
        const p = board[r][tc];
        if(p===EMPTY) continue;
        if(sideOf(p)===opp){
          const upc = p.toUpperCase();
          if(upc==='R') return true;
          break;
        } else break;
      }

      // 4) Cannons (need one screen to capture)
      // Up
      {
        let tr = r-1; let screen = false;
        for(; tr>=0; tr--){
          const p = board[tr][c];
          if(p===EMPTY) continue;
          if(!screen){ screen = true; continue; }
          // after screen, first piece must be enemy to capture
          if(sideOf(p)===opp && p.toUpperCase()==='C') return true;
          break;
        }
      }
      // Down
      {
        let tr = r+1; let screen = false;
        for(; tr<10; tr++){
          const p = board[tr][c];
          if(p===EMPTY) continue;
          if(!screen){ screen = true; continue; }
          if(sideOf(p)===opp && p.toUpperCase()==='C') return true;
          break;
        }
      }
      // Left
      {
        let tc = c-1; let screen = false;
        for(; tc>=0; tc--){
          const p = board[r][tc];
          if(p===EMPTY) continue;
          if(!screen){ screen = true; continue; }
          if(sideOf(p)===opp && p.toUpperCase()==='C') return true;
          break;
        }
      }
      // Right
      {
        let tc = c+1; let screen = false;
        for(; tc<9; tc++){
          const p = board[r][tc];
          if(p===EMPTY) continue;
          if(!screen){ screen = true; continue; }
          if(sideOf(p)===opp && p.toUpperCase()==='C') return true;
          break;
        }
      }

      // 5) Advisors and Elephants (rare but include)
      const diag1 = [[1,1],[1,-1],[-1,1],[-1,-1]];
      for(const [dr,dc] of diag1){
        const sr = r+dr, sc = c+dc;
        if(inside(sr,sc)){
          const p = board[sr][sc];
          if(p!==EMPTY && sideOf(p)===opp && p.toUpperCase()==='A'){
            // Advisors confined to palace; if it's there, it can attack diagonally 1
            return true;
          }
        }
      }
      const diag2 = [[2,2],[2,-2],[-2,2],[-2,-2]];
      for(const [dr,dc] of diag2){
        const sr = r+dr, sc = c+dc;
        const mr = r+dr/2, mc = c+dc/2;
        if(inside(sr,sc) && inside(mr,mc)){
          const p = board[sr][sc];
          if(p!==EMPTY && sideOf(p)===opp && p.toUpperCase()==='E'){
            // Elephant eye must be empty and attacker must be on its own side of river;
            const onOwnSide = (sideOf(p)==='r') ? (sr>=5) : (sr<=4);
            if(onOwnSide && board[mr][mc]===EMPTY) return true;
          }
        }
      }

      // No attackers found
      return false;
    }

    function isCheckmate(board, side){
      if(!inCheck(board, side)) return false;
      const mv = generateLegalMoves(board, side);
      return mv.length===0;
    }
    function isStalemate(board, side){
      if(inCheck(board, side)) return false;
      const mv = generateLegalMoves(board, side);
      return mv.length===0;
    }

    // Evaluation
    const PIECE_VALUE = {
      'K': 10000, 'A': 200, 'E': 200, 'H': 400, 'R': 900, 'C': 450, 'S': 100
    };
    function evaluate(board){
      // Simple material balance (Red - Black) + small bonuses for advanced soldiers, safe king
      let score = 0;
      for(let r=0;r<10;r++){
        for(let c=0;c<9;c++){
          const p = board[r][c];
          if(p===EMPTY) continue;
          const v = PIECE_VALUE[p.toUpperCase()] || 0;
          if(isUpper(p)) score += v; else score -= v;
          if(p.toUpperCase()==='S'){
            // encourage advanced soldiers
            score += isUpper(p) ? ( (9 - r) * 3 ) : ( - r * 3 );
          }
        }
      }
      return score;
    }

    // AI: Alpha-beta with simple move ordering
    function findBestMove(board, side, depth){
      const maximizing = (side==='r');
      let bestMove = null;
      let bestScore = maximizing ? -Infinity : Infinity;

      const moves = generateLegalMoves(board, side);
      if(moves.length===0) return null;

      // Move ordering: captures first, by MVV-LVA
      moves.sort((a,b)=> moveOrderScore(b) - moveOrderScore(a));

      const alphaBeta = (depth, alpha, beta, side) => {
        const legalMoves = generateLegalMoves(board, side);
        if(depth===0 || legalMoves.length===0){
          const val = evaluate(board);
          return val;
        }
        // Order
        legalMoves.sort((a,b)=> moveOrderScore(b) - moveOrderScore(a));
        if(side==='r'){
          let value = -Infinity;
          for(const m of legalMoves){
            applyTemp(board, m);
            const sc = alphaBeta(depth-1, alpha, beta, 'b');
            undoTemp(board, m);
            if(sc > value){ value = sc; if(depth===aiDepth) bestMove = m; }
            alpha = Math.max(alpha, value);
            if(alpha >= beta) break; // beta cutoff
          }
          return value;
        } else {
          let value = Infinity;
          for(const m of legalMoves){
            applyTemp(board, m);
            const sc = alphaBeta(depth-1, alpha, beta, 'r');
            undoTemp(board, m);
            if(sc < value){ value = sc; if(depth===aiDepth) bestMove = m; }
            beta = Math.min(beta, value);
            if(alpha >= beta) break; // alpha cutoff
          }
          return value;
        }
      };

      alphaBeta(depth, -Infinity, Infinity, side);
      return bestMove || moves[0];
    }

    function moveOrderScore(m){
      const capV = m.captured ? (PIECE_VALUE[m.captured.toUpperCase()] || 0) : 0;
      const moverV = PIECE_VALUE[m.piece.toUpperCase()] || 0;
      const captureBonus = capV*10 - moverV*0.2; // MVV-LVA-ish
      const centerBonus = (4 - Math.abs(4 - m.to.c)) + (4.5 - Math.abs(4.5 - m.to.r))*0.3;
      const promoBonus = (m.piece.toUpperCase()==='S') ? (isUpper(m.piece) ? (rProgress(m) * 0.5) : (rProgress(m) * 0.5)) : 0;
      return (m.captured?1000:0) + captureBonus + centerBonus + promoBonus;
    }
    function rProgress(m){
      // Positive for advancing soldiers
      return isUpper(m.piece) ? (m.from.r - m.to.r) : (m.to.r - m.from.r);
    }

    // Initialize
    resizeCanvas();
    resetGame();

  })();
  </script>
</body>
</html>
